#  -----------------------------------------------------------------------------
#' cognac: Core Gene Alignement Concatenation
#  2019/07/15
#  Ryan D. Crawford
#  -----------------------------------------------------------------------------
#' @description The cognac function identifies shared genes to be used as 
#'   phylogenetic markers within the input set of genomes. Marker genes are  
#'   aligned individually with mafft and concatenated into a single alignment  
#'   for downstream phylogenetic analysis.
#' @param fastaDir Directory containing the fasta files. By default, this uses
#'   all of the files in the directory. If there are additional files in this 
#'   directory "fastaExt" can also be supplied to select only the appropriate 
#'   files. This argument is incompatible with "fastaFiles," which can be used
#'   to supply the paths to the fasta files as a character vector.
#' @param fastaExt Optional file extension for the fasta files.
#' @param featureDir Directory containing the Gff3 files, functionality is 
#'   the same as the "fastaDir" argument. Incompatible with "featureFiles"
#' @param featureExt Optional extension used on the gff files 
#' @param fastaFiles A character vector with the paths to the the fasta files 
#'   for each genome can be input. Incompatible with "fasta dir."
#' @param featureFiles A character vector with a gff3
#'  for each genome
#' @param outDir Directory to write the alignments, other output files, 
#'   and temp files created by cd-hit and mafft. Defaults to the current 
#'   working directory.
#' @param runId Optional string to prepend to the output files.
#' @param genomeIds Optional character vector with a unique ID for each 
#'   genome. If not supplied, a genome id is created by removing the file 
#'   extension from the fasta file. Genome Ids will be used as the headers
#'   in the alignment file.
#' @param geneEnv Optional. Environment created by "CreateGeneDataEnv", this
#'   allows a user to parse the genomic data ahead of time. This may be 
#'   useful when troubleshooting parameters with respect to the alignment
#'   or cd-hit clustering step.
#' @param minGeneNum An integer specifying the minimum number of genes to
#'   use in creating the alignment. Default: 1.
#' @param outGroup Optional character vector of genomes IDs that are not used
#'   in selecting core genes. An out-group is useful for many phylogenetic 
#'   analysis, but the intersection of genes in all genomes in the analysis
#'   may be smaller if phylogenetically divergent genomes are included when 
#'   selecting marker genes. This enables identification of an optimal set of
#'   maker genes while still maintaining an outgroup for down-stream analysis.
#' @param maxMissGenes Optional double specifying what fraction of genes are
#'   permitted to be missing to be allowed to be included in the alignment
#'   If an out-group is input these genomes are not removed.
#' @param coreGeneThresh Optional double specifying what fraction of genomes
#'   that a gene must occur to be considered core. Defaults to 0.99.
#' @param copyNumTresh Optional double specifying what fraction of genomes
#'   that a gene can be duplicated in and remain in the analysis. If a gene
#'   is duplicated, the first gene is taken and used in the alignment.
#'   Defaults to 0.001 -- a gene can be duplicated in 1 in 1000 genomes. 
#' @param threadVal Number of threads available. Defaults to all available 
#'   threads. 
#' @param distMat Optional logical to create a distance matrix. If true, a
#'   distance matrix is calculated as the pairwise number of mutations 
#'   between genomes. Stored in the output environment as "distMat."
#' @param njTree Optional logical to create a neighbor joining tree with ape.
#'   Returned to the output environment as "njTree" and the path to the neighbor 
#'   joining tree is written to the output directory. Defaults to false.
#' @param mapNtToAa Optional logical to to convert the aa alignment to dna.
#'   Defaults to false.
#' @param keepTempFiles Optional logical to keep any temporary files 
#'   generated by mafft of cd-hit. 
#' @param percId Optional double for the identity threshold for identifying
#'   orthologous genes by cd-hit. See "-c" in the cd-hit manual. Defaults 
#'   to 0.7. 
#' @param algnCovg Optional double for the maximum disparity in the length
#'   of the genes to be considered orthologous by cd-hit. See "-aL" in the
#'   cd-hit manual. Defaults to 0.8.
#' @param cdHitFlags Optional string with parameters to pass to cd-hit to 
#'   define clusters aside from "-c" and "-aL" that can be used to define the
#'   clustering parameters.
#' @param mafftOpts # Optional. Arguments for mafft: mafft [mafftOpts] in > out
#' @return An environment with the alignment data. Variables included
#'   by default are "aaAlgnPath" and "metaData." If reverse translated,
#'   the alignment is present under "ntAlgnPath," alignment distance matrix
#'   is stored under "distMat"
#' @export
#  -----------------------------------------------------------------------------

cognac = function(
  fastaDir,       # Directory containing the fasta files
  featureDir,     # Directory containing the Gff3 files 
  fastaFiles,     # Fasta files for the input genomes
  featureFiles,   # Gff3 files for the input genomes
  fastaExt,       # Extension used on the fasta files
  featureExt,     # Extension used on the gff files 
  genomeIds,      # Vector of genomes to
  geneEnv,        # Optional. Environment created by "CreateGeneDataEnv"
  outDir,         # Optional. Directory to write the output files
  runId,          # Optional. Run ID to appent to output files
  minGeneNum,     # Optional. Minimium number of genes to build the tree
  maxMissGenes,   # Optional. maximum fraction of missing genes
  coreGeneThresh, # Optional. Fraction of genomes with gene to quality as core
  copyNumTresh,   # Optional. Fraction of genomes for a gene to be single copy
  threadVal,      # Optional. Number of threads available for mafft
  distMat,        # Optional. Bool to create a distance matrix
  njTree,         # Optional. Bool to create a neighbor joining tree
  mapNtToAa,      # Optional. Bool to convert the aa alignment to dna
  outGroup,       # Optional. Vector of genomes to exclude for gene selection
  keepTempFiles,  # Optional. Bool to keep mafft and cd-hit files
  percId,         # Optional. Percent ID for the Cd-hit
  algnCovg,       # Optional. Percent alignment coverage for the Cd-hit
  cdHitFlags,     # Optional. Parameters to pass to cd-hit to define clusters
  mafftOpts       # Optional. Arguments for mafft. mafft [mafftOpts] in > out
  )
{
  startTime = Sys.time() # Start the timer
  # ---- Parse the input arguments ---------------------------------------------

  # If the data has not already been parsed, check the arguments and 
  # get the paths to the input files ready to parse the data.
  if ( missing( geneEnv ) )
  {
    # Make sure that there aren't incompatible arguments with respect to 
    # fastaFiles and fastaDir
    if ( ( !missing(fastaFiles) && !missing(fastaDir) ) ||  
      ( missing(fastaFiles) && missing(fastaDir) ) 
      )
    {
      errorMsg = paste0(
        "Input arguments must contain one of \"fastaFiles\" (",
        "character vector with paths to fasta files)",
        " or \"fastaDir\"(directory containing fasta files)"
        )
      stop( errorMsg )
      
    } else if ( missing(fastaFiles) ) {

      # Get the paths to the fasta files 
      fastaFiles = GetFilePaths( fastaDir, fastaExt )
    }
    
    # Make sure that there aren't incompatible arguments with respect to 
    # fastaFiles and fastaDir
    if ( ( !missing(featureFiles) && !missing(featureDir) ) ||  
      ( missing(featureFiles) && missing(featureDir) )   
      )
    {
      errorMsg = paste0(
        "Input arguments must contain one of \"featureFiles\" (",
        "character vector with paths to fasta files)",
        " or \"featureDir\"(directory containing fasta files)"
        )
      stop( errorMsg )
      
    } else if ( missing(featureFiles) ) {
      
      # Get the paths to the fasta files 
      featureFiles = GetFilePaths( featureDir, featureExt )
    }
    
    
    # Check that the size of the vectors are the same length
    if ( length(fastaFiles) != length(featureFiles) )
    {
      errorMsg = paste0( 
        "The length of the fasta files (", length(fastaFiles), ")", 
        " is not equal to the length of the feature files (", 
        length(featureFiles), ")\n"
        )
      
      stop( errorMsg )
    }
    
    if ( length( fastaFiles ) == 0 ) stop( "No fasta files were input..." )
    
    # Create the genome IDs and/or check the ids to ensre they are valid
    genomeIds = GetGenomeIds(
      featureFiles, fastaFiles, fastaExt, featureExt, genomeIds
      )
    nGenomes = length( featureFiles )
    
  } else {
    nGenomes = length( geneEnv$gfList )
  }
  
  # If now output directory was specified, write to the working directory
  if ( missing(outDir) )
  {
    outDir = ''
  # Make sure the output directory ends in a '/'
  } else if ( !grepl("/$", outDir) && outDir != '' ) {
    outDir = paste0( outDir, '/' )
  }
 
  # If missing a run ID assign it to an empty string  
  if ( missing( runId ) )
  {
    runId = ''
  # Check that the run ID ends in an underscore
  } else if ( !grepl("_$", runId) ) {
    runId = paste0( runId, '_')
  }
  
  # Make a temporary directory to store any files made during the run
  tempDir = paste0( outDir, runId, "temp_cognac_files/" )
  if ( !file.exists( tempDir ) ) system( paste( "mkdir", tempDir ) )

  # By default, delete any temporary file that are created
  if ( missing(keepTempFiles) ) keepTempFiles = FALSE

  # Default to one available thread
  if ( missing(threadVal) ) threadVal = as.numeric( future::availableCores() )

  # Create a distance matrix with the pairwise distances between isolates
  if ( missing(distMat) ) distMat = FALSE

  # Set the bool ot create the neighbor joining tree
  if ( missing( njTree ) )
  {
    njTree = FALSE
  } else if ( njTree ) {
    distMat = TRUE
  }
  
  # By defautlt do not create the nt alignment 
  if ( missing(mapNtToAa) ) mapNtToAa = FALSE
  
  # ---- Set up multithreadding ------------------------------------------------

  # It's really dumb that you have to do this, but remove the limitation on the
  # maximum allowable object size by future sapplyf
  options( future.globals.maxSize = Inf )

  # Set up multithreadding via future
  plan = future::tweak( future::multicore, workers = threadVal )
  future::plan( plan )

  # Set the number of threads fot TBB
  RcppParallel::setThreadOptions( numThreads = threadVal )

  # ---- Find the target genes using the gene ids ------------------------------

  if ( outDir == '' ) wd = "the current working directory"
  else wd = outDir
  cat(
    "\n\nCreating concatenated gene alignment:\n",
    "  -- ", nGenomes, " genomes were input\n",
    "  -- Writing results to: ", wd, "\n",
    "  -- Running on: ", threadVal, " cores\n",
    sep = ''
    )
  
  # Parse the input files. This creates an environment that stores:
  # genome ids, list of parsed gff files, a vector of amino acid sequences, 
  # and a vector with the gene Ids. Additionally, the amino acid sequences
  # are written to create the input file for cd-hit. 
  cat("\nStep 1: parsing the data on the input genomes\n")
  if ( missing( geneEnv ) )
    geneEnv = CreateGeneDataEnv( featureFiles, fastaFiles, genomeIds, tempDir )
  stepTime = GetSplit( startTime )
  
  # Identify orthologous genes with cd-hit
  cat("\nStep 2: finding orthologs with cd-hit\n")
  FindCogs(
    geneEnv, tempDir, percId, algnCovg, threadVal, cdHitFlags, maxMissGenes
    )
  stepTime = GetSplit( startTime )
  
  # Find the copy number of each gene. Any gene that is present in 
  # as multiple copies in greater than the "copyNumTresh" is removed 
  # from the analysis.
  cat("\nStep 3: filtering for single copy genes\n")
  FilterMultiCopyGenes( geneEnv, copyNumTresh )
  stepTime = GetSplit( stepTime )
  
  # Use the cd-hit results to identify a set of core genes present in all of
  # the input genomes.
  cat("\nStep 4: selecting genes to include in the alignment\n")
  SelectAlgnGenes( geneEnv, minGeneNum, coreGeneThresh, maxMissGenes, outGroup )
  stepTime = GetSplit( stepTime )
  
  # Individually create a new fasta file for each gene and generate the
  # alignment each gene with mafft
  cat( "\nStep 5: aligning and concatenating orthologous genes\n" )
  algnPath = ConcatenateGeneAlgns( geneEnv, outDir, runId, mafftOpts )
  stepTime = GetSplit( stepTime )

  # Create the environment with the objects to export
  cat( "\nStep 6: creating output files\n" )
  algnEnv            = new.env()
  algnEnv$geneData   = CreateGeneMetaData( geneEnv, mapNtToAa )
  algnEnv$aaAlgnPath = algnPath
  
  # If requested, convert the AA alignment to DNA
  if ( mapNtToAa )
  {
    # Reverse translate the alignment and get the path to the newly 
    # created nt alignment
    algnPath = ReverseTranslateAlgn( geneEnv, algnPath, outDir, runId )
    
    # Assign the path to the nt alignment to the output environment
    algnEnv$ntAlgnPath = algnPath
  }
  
  # If requested, create a distance matrix with the
  if ( distMat )
    algnEnv$distMat = CreateAlgnDistMat( algnPath, "shared" )
  
  # If requested, make a neighbor joining tree with ape
  if ( njTree )
  {
    algnEnv$njTree = ape::nj( as.dist( algnEnv$distMat ) )
    
    # Write the tree to the output directory
    treePath = paste0( outDir, runId, "cognac_nj.tre" )
    ape::write.tree( algnEnv$njTree, treePath )
  }
  
  # Remove any temp files
  if ( !keepTempFiles ) 
    system( paste( "rm -r", tempDir ) )
  stepTime = GetSplit( stepTime )
  
  # Write the data on the alignment genes
  write.table( 
    algnEnv$geneData, 
    file      = paste0( outDir, runId, "cognac_gene_data.tsv" ), 
    append    = FALSE, 
    sep       = "\t",
    row.names = FALSE,
    col.names = TRUE
    )
  
  cat( "\nRun complete\n" )
  cat( "  -- Amino acid alignment written to:", algnEnv$aaAlgnPath, '\n' )
  if ( mapNtToAa )
    cat( "  -- Nucleotide alignment written to:", algnEnv$ntAlgnPath, '\n' )
  if ( njTree )
    cat( "  -- Neighbor joining tree written to:", treePath, '\n' )
  
  endTime = GetSplit( startTime )
  cat( "\n\n" )
  
  return( algnEnv )
}

# ------------------------------------------------------------------------------
